\documentclass[a4paper]{article}

% \usepackage{libertine}%% Only as example for the romans/sans fonts
\usepackage[T1]{fontenc}
\usepackage[colorlinks, allcolors=blue]{hyperref}
\usepackage[nottoc]{tocbibind}
\usepackage[scaled=0.85]{beramono}
\usepackage[utf8]{inputenc}
\usepackage{changepage}
\usepackage{color}
\usepackage{courier}
\usepackage{enumitem}
\usepackage{fullpage}
\usepackage{listings}
\usepackage{nameref}
\usepackage{parskip}
\usepackage{url}
\usepackage{xcolor}
\usepackage[multiple]{footmisc}
\usepackage{xspace}

\usepackage[bordercolor=white,backgroundcolor=gray!30,linecolor=black,colorinlistoftodos]{todonotes}
\newcommand{\takeaway}[1]{\todo[color=yellow,inline]{#1}}

\usepackage[style=iso]{datetime2}
\usepackage{biblatex}
\addbibresource{bibliography.bib}

% Solarized colour scheme for listings
\definecolor{solarized@base03}{HTML}{002B36}
\definecolor{solarized@base02}{HTML}{073642}
\definecolor{solarized@base01}{HTML}{586e75}
\definecolor{solarized@base00}{HTML}{657b83}
\definecolor{solarized@base0}{HTML}{839496}
\definecolor{solarized@base1}{HTML}{93a1a1}
\definecolor{solarized@base2}{HTML}{EEE8D5}
\definecolor{solarized@base3}{HTML}{FDF6E3}
\definecolor{solarized@yellow}{HTML}{B58900}
\definecolor{solarized@orange}{HTML}{CB4B16}
\definecolor{solarized@red}{HTML}{DC322F}
\definecolor{solarized@magenta}{HTML}{D33682}
\definecolor{solarized@violet}{HTML}{6C71C4}
\definecolor{solarized@blue}{HTML}{268BD2}
\definecolor{solarized@cyan}{HTML}{2AA198}
\definecolor{solarized@green}{HTML}{859900}

\lstset{
  basicstyle=\footnotesize\ttfamily,
  rangeprefix=//\ ,
  includerangemarker=false,
}

% Define C++ syntax highlighting colour scheme
\lstdefinelanguage{cpp}{
  language=C++,
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  numberstyle=\footnotesize,
  tabsize=2,
  breaklines=true,
  escapeinside={@}{@},
  numberstyle=\tiny\color{solarized@base01},
  keywordstyle=\color{solarized@green},
  stringstyle=\color{solarized@cyan}\ttfamily,
  identifierstyle=\color{solarized@blue},
  commentstyle=\color{solarized@base01},
  emphstyle=\color{solarized@red},
  frame=single,
  rulecolor=\color{solarized@base2},
  rulesepcolor=\color{solarized@base2},
  showstringspaces=false,
}

\lstdefinelanguage{diff}{
  morecomment=[f][\color{blue}]{@@},           % group identifier
  morecomment=[f][\color{red}]{-},             % deleted lines
  morecomment=[f][\color{green!50!black}]{+},  % added lines
  morecomment=[f][\color{magenta}]{---},       % diff header lines
  morecomment=[f][\color{magenta}]{+++},
}

\lstdefinelanguage{plus}{
  basicstyle=\footnotesize\ttfamily\color{green!50!black},
  emph={see,below,TypeSwitch,unspecified},
  emphstyle=\itshape
}

\lstdefinelanguage{signature}{
  basicstyle=\ttfamily\color{green!50!black},
  emph={see,below,TypeSwitch,unspecified},
  emphstyle=\itshape
}

\newcommand{\desc}[1]{\textit{#1}}
\newcommand{\requires}{\desc{Requires}}
\newcommand{\effects}{\desc{Effects}}
\newcommand{\precondition}{\desc{Precondition}}
\newcommand{\postcondition}{\desc{Postcondition}}
\newcommand{\throws}{\desc{Throws}}
\newcommand{\returns}{\desc{Returns}}
\newcommand{\remarks}{\desc{Remarks}}
\newcommand{\exceptionsafety}{\desc{Exception Safety}}
\newcommand{\fullref}[1]{\ref{#1} \nameref{#1}}

\def\code#1{\texttt{#1}}
\newcommand\mypound{\protect\scalebox{0.8}{\raisebox{0.4ex}{\#}}}
\newcommand{\CC}{C\nolinebreak\hspace{-.05em}\raisebox{0.4ex}{\resizebox{!}{0.6\height}{\bf++}}}
\newcommand{\cplusplus}{\protect\CC}
\newcommand{\this}{\code{this}\xspace}
\newcommand{\self}{\code{self}\xspace}
\newcommand{\cvref}{\emph{cv-ref qualifiers}\xspace}
\newcommand{\spaceship}{\code{<=>}\xspace}
\def\stableref#1{[#1]}
\def\concept#1{\emph{#1}}
\newcommand{\StrongOrder}{\code{strong\_order}\xspace}

\date{}
\title{Allow user overriding of \StrongOrder in P0768R1}
\author{Gašper Ažman}

\newcommand{\emailaddressa}{gasper.azman@gmail.com}
\newcommand{\emaila}{\href{mailto:\emailaddressa}{\emailaddressa}}

\begin{document}

\maketitle

\begin{flushright}
  \begin{tabular}{ll}
    Document \mypound{}: &DxxxxR0\\
    Date:       &2018-01-06\\
    Audience:   &Library Working Group\\
    Reply-to:   &\author{Gašper Ažman}, \emailaddressa\\
  \end{tabular}
\end{flushright}

{\hypersetup{linkcolor=black}
  \tableofcontents
}

\section{Status of this paper}

This paper is a defect-report to a library extension that has been voted into
the working draft as part of P0768R1\cite{p0768r1}.

The wording for the entire fix is not provided in this paper, and shall be
written if this paper receives support and further guidance on direction.


\section{Abstract}

Rule 1.1 for \StrongOrder algorithm (an exception for iec559 (floating point)
types) suggests the algorithm is a customization point, but the rest of the
rules disallow that.

This paper makes a case for why \StrongOrder should be a customization point,
and then explores the consequences and a possible fix.


\section{Current Status}

For reference, the current proposal for the \StrongOrder algorithm looks like
this:

\code{template<class T>\\
constexpr strong\_ordering strong\_order(const T\& a, const T\& b);}

\begin{enumerate}
  \item Effects: Compares two values and produces a result of type \code{strong\_ordering}:

    \begin{enumerate}[label*=\arabic*.]
      \item If \code{numeric\_limits<T>::is\_iec559} is true, returns a result of
        type \code{strong\_ordering} that is consistent with the totalOrder
        operation as specified in ISO/IEC/IEEE 60559.
      \item Otherwise, returns \code{a \spaceship b} if that expression is
        well-formed and convertible to \code{strong\_ordering}.
      \item Otherwise, if the expression \code{a \spaceship b} is well-formed, then
        the function shall be defined as deleted.
      \item Otherwise, if the expressions \code{a == b} and \code{a < b} are each
        well-formed and convertible to \code{bool},\\
        returns \code{strong\_ordering::equal} when \code{a == b} is
        \code{true},\\
        otherwise returns \code{strong\_ordering::less} when \code{a < b} is
        \code{true},\\
        and otherwise returns \code{strong\_ordering::greater}.
      \item Otherwise, the function shall be defined as deleted.
    \end{enumerate}
\end{enumerate}


\section{Exposition: The Natural and Default Orderings}

Obviously, there are many reasons for sorting. However, this paper is chiefly
concerned with the division between the \emph{natural ordering} and the
\emph{default total ordering} as required for \concept{Regular}\footnote{The
Elements of Programming concept, not the ISO C++ Regular, which is weaker.}
types by Stepanov and McJones in their seminal work Elements of Programming
(\cite{EoP}, page 62, section 4.4).

The \textbf{natural ordering} is the ordering that makes semantic sense for a
type. This is the ordering that operator \spaceship and its library extensions
are tailor-made for: not every type is ordered (or even equality-comparable),
and when a type supports an ordering, it might be strong, partial, or weak.

We use these orderings when we need them to make sense - heaps, scheduling tasks
by topological sorts, various displays for users, etc. Not all value types have
a natural ordering, because not all types are ordered. The gaussian integers
are one such type.

The \textbf{default ordering}\footnote{The name comes from Elements of
Programming} is the strongest ordering that a type admits.
Its equality is defined by value-substitutability, and unequal elements must be
ordered; it is always strong and total, and might not make semantic sense.

According to Elements of Programming, every \concept{Regular} type should
provide a default ordering.

A type with a default ordering is far more useful than one without; ordering
enables the use of tree-based containers (i.e. \code{map}, \code{set}), and
algorithms based on sorted data (\code{unique}, the various set algorithms, and
the various versions of binary search) -- and this is just the tip of the
iceberg. The only requirement for the above is having \emph{a} total strong
ordering - what the ordering \emph{means} is utterly irrelevant.

The lexicographic ordering of the gaussian integers is a good example of a
default ordering.

Another excellent example is \code{float} -- its various \code{NaN}s and
infinities are not ordered, which is why its natural ordering is not suitable as
a default ordering. However, iec559 defines a total strong ordering for those
values, thus enabling the uses outlined above.


\subsection{On Compatibility Between the Natural and Default Orderings}

Elements of Programming specifies that for types where the natural and default
orderings differ, the default ordering should be compatible with the natural
one: that is, if \code{a} and \code{b} are comparable and compare unequal under
\spaceship, the default order produces the same result (less or greater).

However, requiring this in the language of the standard library as a mandatory
semantic constraint seems like a bad idea.

For instance, if one takes the gaussian integers ordered by the
manhattan-distance to zero (sum of absolute values of the two components), the
compatible total order (a lexicographic ordering of every equivalence class) is
far slower to compute than the simple lexicographic one.

Furthermore, if needed, a compatible total order can always be achieved on the
fly by comparing with the natural order first - if the result is \code{less} or
\code{greater}, keep the result - otherwise, fall back on the default ordering.


\section{Problem Description}

The current C++ standard does not have an explicitly designated customization
point for providing a default ordering. Elements of Programming uses
\code{less<T>::operator()}, as does the global order for pointers; but in
the wake of operator \spaceship, \code{less<T>} is missing features, such as
computing equality without calling it twice. It has also failed to get adoption
for this purpose throughout the years.

The wording of point 1.1 of the \StrongOrder algorithm suggests that
\StrongOrder is finally this missing customization point for specifying a
default ordering for types whose natural ordering is not strong and total, since
it does exactly that for the iec559 types.

The issue is that the rest of the points make this function rather unsuitable
for use as a customization point, since the language explicitly makes it not
SFINAE-friendly. In the event that it cannot be synthesized, it is marked as
\emph{deleted}, and not as \emph{"shall not participate in overload
resolution"}.


\section{Code Example}

Let me illustrate on a trivial example. Say we have a template struct
representing the gaussian integers, with a "natural order"\footnote{There is no
natural order on gaussian integers, but humor this example, please.} defined by
the manhattan distance from $0+0i$. This struct still defines a \StrongOrder to
be \concept{Regular}.

\begin{lstlisting}[language=cpp]
  namespace user {
    template <typename T>
    struct gaussian {
      static_assert(std::is_integral_v<T>);
      T re;
      T im;

      constexpr std::strong_equality operator==(gassian const& other) const {
        return re == other.re && im == other.im;
      }
      constexpr std::weak_ordering operator<=>(gaussian const& other) const {
        return (*this == other) ? std::weak_ordering::equal
        : (abs(*this) == abs(other))
        ? std::weak_ordering::equivalent
        : abs(*this) <=> abs(other);
      }
      friend constexpr T abs(gaussian const&) {
        using std::abs;
        return abs(re) + abs(im);
      }
      friend constexpr std::strong_ordering strong_order(gaussian const& x,
      gaussian const& y) {
        // compare lexicographically
        return std::tie(x.re, x.im) <=> std::tie(y.re, y.im);
      }
    };
  }
\end{lstlisting}

Consider a transparent ordering operator for \code{map}:
\begin{lstlisting}[language=cpp]
  struct strong {
    struct less {
      template <typename T, typename U>
      bool operator()(T const& x, U const& y) {
        using std::strong_order; // use ADL
        return strong_order(x, y) < 0;
      }
      using is_transparent = std::true_type;
    };
    // also equal, greater, ge_eq, less_eq etc.
  };
\end{lstlisting}

Also say we had a type with an implicit conversion to our \code{gaussian}:
\begin{lstlisting}[language=cpp]
  template <typename T>
  struct lazy {
    std::function<T()> make;
    operator T() const { return make(); }
  };
\end{lstlisting}

This function now fails to compile, because the chosen \StrongOrder is deleted.
\begin{lstlisting}[language=cpp]
  bool exists(lazy<gaussian<int>> const& x,
  std::set<gaussian<int>, strong::less> const& in) {
    /* imagine this being a template in both parameters - it's pretty normal */
    return in.count(x);
  }
\end{lstlisting}


\section{Proposal}

\subsection{Make \StrongOrder An Explicit Customization Point}

Depending on the final direction of the wording on customization points (either
the current one, with an emphasis on \emph{shall not participate in overload
resolution}, or the one outlined in P0551R0\cite{p0551r0}, the wording shall
differ here.

I am asking LWG for guidance on this subject.


\subsection{Remove the iec559 Exception (point 1.1)}

Since this paper adds explicit support for this customization point, the
exception can now be implemented using whichever mechanism for customization
points is chosen, and this special case moved to that part of the standard. For
instance, a "more specialized" template based on a \code{requires} clause and
the \code{numeric\_limts<T>::is\_iec559} trait can be added to \code{namespace
std}.

The minimal fix for the current situation would be:

Change point 1.3 to read:
\emph{Otherwise, if the expression \code{a \spaceship  b} is
well-formed,\footnote{Note: point 1.2 already takes care of the case where
\spaceship provides a strong (and thus valid default) order.} the function does
not participate in overload resolution.}


After the list, add a Note:

\emph{If operator \spaceship provides an order weaker than strong, this function
allows the provision of a default strong order for a user-defined type. In that
case, \StrongOrder should define a strict, total ordering.}


\subsection{Fix The Rules for Synthesis of Weaker Algorithms}
The algorithms section contains a few other algorithms:\footnote{Not to be
  confused with the types of their results; those end in \code{-ing}:
\code{strong\_ordering}, \code{weak\_ordering} etc.}

\begin{itemize}
  \item \code{weak\_order(const T\& a, const T\& b)}
  \item \code{partial\_order(const T\& a, const T\& b)}
  \item \code{strong\_equal(const T\& a, const T\& b)}
  \item \code{weak\_equal(const T\& a, const T\& b)}
  \item \code{partial\_equal(const T\& a, const T\& b)}
\end{itemize}

Intuitively, one would expect that if \StrongOrder is available, then so are
\code{strong\_equal}, \code{weak\_order} and \code{partial\_order} (with
\code{weak\_equal} and \code{partial\_equal} being consequences of those). The
current situation seems to provide for that by accident\footnote{the rules for
those algorithms are identical but for the iec559 exception in \StrongOrder;
since floating-point types possess \code{operator<} and \code{operator==}, they
enable the synthesis of all those algorithms.}, with no explicit reference to
this fact.

However, if \StrongOrder is the customization point for a default order
that \emph{may} be stronger than the order on operator \spaceship, then the
above expectation may no longer hold for such types (you might have \StrongOrder
but not \code{weak\_order}, for instance).

The fix-up for each of the sections describing the above primitives would be to
insert, after point x.1 (which describes the algorithm in terms of \spaceship)
the automatic fallback to a call to \StrongOrder, if it is resolvable 
through an unqualified call (thus enabling argument-dependent lookup).


\subsection{Alternative}
If the purpose of \StrongOrder is not enabling a default-ordering for
types, the iec559 exception should be removed from the wording, and a different
customization point (perhaps called \code{total\_order}) added for the express
purpose of providing an arbitrary total order on the entire domain of a type.



\section{Acknowledgments} 
I would like to thank
\begin{description}
  \item[Roger Orr] for bringing this to my attention;
  \item[Thomas Köppe] for his valuable comments, review, and most of all some
    extremely clear and laconic wording;
  \item[Sam Finch] for \emph{thoroughly} breaking my examples, some example
    code, great substantive comments, and pointing out that the current
    definition actually breaks types that define a partially-ordered set of
    comparison operators;
  \item[Richard Smith] for further fixing my example in light of Concepts.
\end{description}

Thanks!

\printbibliography


\end{document}

