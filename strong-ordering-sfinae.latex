\documentclass[a4paper]{article}

% \usepackage{libertine}%% Only as example for the romans/sans fonts
\usepackage[T1]{fontenc}
\usepackage[colorlinks, allcolors=blue]{hyperref}
\usepackage[nottoc]{tocbibind}
\usepackage[scaled=0.85]{beramono}
\usepackage[utf8]{inputenc}
\usepackage{changepage}
\usepackage{color}
\usepackage{courier}
\usepackage{enumitem}
\usepackage{fullpage}
\usepackage{listings}
\usepackage{nameref}
\usepackage{parskip}
\usepackage{url}
\usepackage{xcolor}
\usepackage[multiple]{footmisc}
\usepackage{xspace}

\usepackage[bordercolor=white,backgroundcolor=gray!30,linecolor=black,colorinlistoftodos]{todonotes}
\newcommand{\takeaway}[1]{\todo[color=yellow,inline]{#1}}

\usepackage[style=iso]{datetime2}
\usepackage{biblatex}
\addbibresource{bibliography.bib}

% Solarized colour scheme for listings
\definecolor{solarized@base03}{HTML}{002B36}
\definecolor{solarized@base02}{HTML}{073642}
\definecolor{solarized@base01}{HTML}{586e75}
\definecolor{solarized@base00}{HTML}{657b83}
\definecolor{solarized@base0}{HTML}{839496}
\definecolor{solarized@base1}{HTML}{93a1a1}
\definecolor{solarized@base2}{HTML}{EEE8D5}
\definecolor{solarized@base3}{HTML}{FDF6E3}
\definecolor{solarized@yellow}{HTML}{B58900}
\definecolor{solarized@orange}{HTML}{CB4B16}
\definecolor{solarized@red}{HTML}{DC322F}
\definecolor{solarized@magenta}{HTML}{D33682}
\definecolor{solarized@violet}{HTML}{6C71C4}
\definecolor{solarized@blue}{HTML}{268BD2}
\definecolor{solarized@cyan}{HTML}{2AA198}
\definecolor{solarized@green}{HTML}{859900}

\lstset{
  basicstyle=\footnotesize\ttfamily,
  rangeprefix=//\ ,
  includerangemarker=false,
}

% Define C++ syntax highlighting colour scheme
\lstdefinelanguage{cpp}{
  language=C++,
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  numberstyle=\footnotesize,
  tabsize=2,
  breaklines=true,
  escapeinside={@}{@},
  numberstyle=\tiny\color{solarized@base01},
  keywordstyle=\color{solarized@green},
  stringstyle=\color{solarized@cyan}\ttfamily,
  identifierstyle=\color{solarized@blue},
  commentstyle=\color{solarized@base01},
  emphstyle=\color{solarized@red},
  frame=single,
  rulecolor=\color{solarized@base2},
  rulesepcolor=\color{solarized@base2},
  showstringspaces=false,
}

\lstdefinelanguage{diff}{
  morecomment=[f][\color{blue}]{@@},           % group identifier
  morecomment=[f][\color{red}]{-},             % deleted lines
  morecomment=[f][\color{green!50!black}]{+},  % added lines
  morecomment=[f][\color{magenta}]{---},       % diff header lines
  morecomment=[f][\color{magenta}]{+++},
}

\lstdefinelanguage{plus}{
  basicstyle=\footnotesize\ttfamily\color{green!50!black},
  emph={see,below,TypeSwitch,unspecified},
  emphstyle=\itshape
}

\lstdefinelanguage{signature}{
  basicstyle=\ttfamily\color{green!50!black},
  emph={see,below,TypeSwitch,unspecified},
  emphstyle=\itshape
}

\newcommand{\desc}[1]{\textit{#1}}
\newcommand{\requires}{\desc{Requires}}
\newcommand{\effects}{\desc{Effects}}
\newcommand{\precondition}{\desc{Precondition}}
\newcommand{\postcondition}{\desc{Postcondition}}
\newcommand{\throws}{\desc{Throws}}
\newcommand{\returns}{\desc{Returns}}
\newcommand{\remarks}{\desc{Remarks}}
\newcommand{\exceptionsafety}{\desc{Exception Safety}}
\newcommand{\fullref}[1]{\ref{#1} \nameref{#1}}

\def\code#1{\texttt{#1}}
\newcommand\mypound{\protect\scalebox{0.8}{\raisebox{0.4ex}{\#}}}
\newcommand{\CC}{C\nolinebreak\hspace{-.05em}\raisebox{0.4ex}{\resizebox{!}{0.6\height}{\bf++}}}
\newcommand{\cplusplus}{\protect\CC}
\newcommand{\this}{\code{this}\xspace}
\newcommand{\self}{\code{self}\xspace}
\newcommand{\cvref}{\emph{cv-ref qualifiers}\xspace}
\newcommand{\spaceship}{\code{<=>}\xspace}
\def\stableref#1{[#1]}
\def\concept#1{\emph{#1}}
\newcommand{\StrongOrder}{\code{strong\_order}\xspace}

\date{2018-01-06}
\title{Allow user overriding of \StrongOrder in P0768R1}
\author{Gašper Ažman}

\newcommand{\emailaddressa}{gasper.azman@gmail.com}
\newcommand{\emaila}{\href{mailto:\emailaddressa}{\emailaddressa}}

\begin{document}

\maketitle

\begin{flushright}
  \begin{tabular}{ll}
  Document \mypound{}: &DxxxxR0\\
  Date:       &2018-01-06\\
  Audience:   &Library Working Group\\
  Reply-to:   &\author{Gašper Ažman}, \emailaddressa\\
  \end{tabular}
\end{flushright}

{\hypersetup{linkcolor=black}
  \tableofcontents
}

\section{Status of this paper}
This paper is a defect-report to a paper that has been voted into the working
draft. It seeks to highlight an issue with the currently proposed
\StrongOrder algorithm.

The wording for the entire fix is not provided in this paper, and shall be
written if this paper receives support.

\section{Problem description}

The paper P0768R1\cite{p0768r1} proposes the library extensions for operator
\spaceship. Among them is the function \code{strong\_order(const T\& a, const
T\& b)}, specified in section \stableref{cmp.alg}.

This is the specification in that paper:

\code{template<class T>\\
constexpr strong\_ordering strong\_order(const T\& a, const T\& b);}

\begin{enumerate}
  \item Effects: Compares two values and produces a result of type \code{strong\_ordering}:

  \begin{enumerate}[label*=\arabic*.]
    \item If \code{numeric\_limits<T>::is\_iec559} is true, returns a result of
      type \code{strong\_ordering} that is consistent with the totalOrder
      operation as specified in ISO/IEC/IEEE 60559.
    \item Otherwise, returns \code{a \spaceship b} if that expression is
      well-formed and convertible to \code{strong\_ordering}.
    \item Otherwise, if the expression \code{a \spaceship b} is well-formed, then
      the function shall be defined as deleted.
    \item Otherwise, if the expressions \code{a == b} and \code{a < b} are each
      well-formed and convertible to \code{bool},\\
      returns \code{strong\_ordering::equal} when \code{a == b} is
      \code{true},\\
      otherwise returns \code{strong\_ordering::less} when \code{a < b} is
      \code{true},\\
      and otherwise returns \code{strong\_ordering::greater}.
    \item Otherwise, the function shall be defined as deleted.
  \end{enumerate}
\end{enumerate}

Point 1.1 hints at the potential for \StrongOrder to be the elusive
\emph{default ordering}, required by Stepanov and McJones for \concept{Regular}
types, to enable sorting for the purposes of speeding up further processing such
as logarithmic searching (\cite{EoP}, page 62, section 4.4). For this purpose,
\emph{any} strong ordering would do.

Elements of Programming stresses that many types do not have a \emph{natural
order}; even then, a \emph{default order} (a total order that respects at least
representational equality) should be provided for all \concept{Regular} types,
because the efficiency gains enabled by sorting are enormous. For types that do
have a natural total order (possibly only in some of the domain), they specify
the \emph{default order} should agree with it wherever defined.

As an example, consider the lexicographic ordering of the gaussian integers.
This forms a total order, and its restriction to the integers (gaussian integers
of the form $n +0j$ agrees with the natural order on the integers.

Unfortunately, the hope of finally having a canonical way of naming the default
ordering\footnote{\code{std::less} was never really the canonical way of
referencing the default ordering, except for pointers.} is destroyed by Point
1.3.

Operator \spaceship seems to be explicitly designed\footnote{Because of the
various orderings that it supports; they map out the semantic gamut of natural
orderings of value types.} to represent the \emph{natural ordering} over the
values of \code{T}. In the case of floating point, iec559 extends this natural
order to a total order, thus providing our fabled \emph{default ordering}.
However, as per point 1.3, the user is not allowed to specify this extension to
\StrongOrder themselves, because the function is specified as deleted -- it
still participates in overload resolution.

\section{Code Example}
Let me illustrate on a trivial example. Say we have a template struct
representing the gaussian integers, which are comparable only if their imaginary
part is 0. This constitutes a partial order.

\begin{lstlisting}[language=cpp]
namespace user {
template <typename T>
struct gaussian {
  static_assert(std::is_integral_v<T>);
  T real;
  T imag;

  // vector-like
  size_t size() const { return 2; }
  T operator[](size_t i) const {
    assert(i < size());
    return i?imag:real;
  }
};

// our library has this type trait...
template <typename T>
struct is_vector_like : std::false_type {};
template <typename T>
struct is_vector_like<gaussian<T>> : std::true_type {};
}
\end{lstlisting}

We can now define its \spaceship operator:

\begin{lstlisting}[language=cpp]
// "natural" ordering on the gaussian integers
#include <compare>
namespace user {
template <typename T>
std::partial_ordering operator<=>(gaussian<T> const& x, gassian<T> const& y) {
  if (x.imag != 0 || y.imag != 0) {
    return std::partial_ordering::unordered;
  }
  return x.real <=> y.real;
}
}
\end{lstlisting}

However, since it is extremely useful to still have \emph{some} total order, we
shall define the \StrongOrder function template:
\begin{lstlisting}[language=cpp]
namespace user {
template <typename T>
std::strong_ordering strong_order(gaussian<T> const& x, gassian<T> const& y) {
  // compare lexicographically
  return std::tie(x.real, x.imag) <=> std::tie(y.real, y.imag);
}
}
\end{lstlisting}

This works, by virtue of the fact that the template is more specialized than the
\code{std::strong\_order} version.

However, consider overloading on a type trait:
\begin{lstlisting}[language=cpp]
namespace user {
template <typename T>
using spaceship_type =
  std::decay_t<decltype(std::declval<T>() <=> std::declval<T>())>;

// trait that will disqualify std::strong_order
template <typename T>
using spaceship_is_not_strong =
  std::bool_constant<!(std::is_convertible_to<spaceship_type<T>,
                                              std::strong_ordering>)>;


// provide a lexicographical order for all vector-like types that define the trait
template <typename T,
          std::enable_if_t<(spaceship_is_not_strong<T>::value &&
                            is_vector_like<T>::value), void*> = nullptr>
std::strong_ordering strong_order(const T & x, const T & y) {
  using std::strong_order;
  assert(x.size() == y.size());
  for (size_t i = 0, s = x.size(); i < s; ++i) {
    auto const result = strong_order(x[i], y[i]); // ADL
    if (!std::is_eq(result)) { return result; }
  }
  return std::strong_ordering::equal;
}
}
\end{lstlisting}

Unfortunatley, this definition is ambiguous with \code{std::strong\_order},
because \code{std::strong\_order} is defined as \emph{deleted}, and not as "does
not participate in overload resolution".

As an illustration of why having an arbitrary total order available, consider
the rest of this example.

Since the standard doesn't yet have an equivalent to \code{std::less} and
\code{std::equal} for \code{std::strong\_order}, let's roll our own:
\begin{lstlisting}[language=cpp]
struct strong {
  struct less {
    template <typename T>
    bool operator()(T const& x, T const& y) {
      using std::strong_order; // use ADL
      return std::is_lt(strong_order(x, y));
    }
  };
  struct equal {
    template <typename T>
    bool operator()(T const& x, T const& y) {
      using std::strong_order; // use ADL
      return std::is_eq(strong_order(x, y));
    }
  };
  // also greater, ge_eq and less_eq...
};
\end{lstlisting}

This allows us to unique a vector of any type whatsoever that provides a
\StrongOrder, even if the type doesn't even provide a comparison operator (or
provides a weak or partial one).

\begin{lstlisting}[language=cpp]
std::vector<gaussian<int>> gaussians = {{1, 0}, {1, 2}, {-1, 2}, {1, 2}};
std::sort(gaussians.begin(), gaussians.end(), strong::less{}):
gaussians.erase(std::unique(gaussians.begin(), gaussians.end(), strong::equal{}));
\end{lstlisting}

It allows us to make a \code{std::set} of these gaussians as well!
\begin{lstlisting}[language=cpp]
std::set<gaussian<int>, strong::less> gaussian_set = {{1, 0}, {1, 2}, {-1, 2}, {1, 2}}
\end{lstlisting}

It should be clear that having a canonical way of shipping an arbitrary total
order with otherwise unordered, partially ordered or weakly-ordered types is
extremely useful for writing efficient generic algorithms.

At last, having a customization point that explicitly says "this is a strong
order on this type" is within reach.

\section{Proposal}
This paper proposes changing point 1.3 to read:

\emph{Otherwise, if the expression \code{a \spaceship  b} is
well-formed,\footnote{Note: point 1.2 already takes care of the case where
\spaceship provides a strong (and thus valid default) order.} the function does
not participate in overload resolution.}


After the list, add a Note:

\emph{If operator \spaceship provides an order weaker than strong, this function
allows the provision of a default strong order for a user-defined type. In that
case, \StrongOrder should define a strict, total ordering compatible
with the weaker ordering, that is, if a and b are comparable and compare unequal
under <=>, \StrongOrder produces the same result (less or greater).}
\footnote{An ordering
weaker than \emph{strong} implies the existence of elements that are unequal,
but are not distinguished (deemed either equivalent or unordered) by \spaceship.}
\footnote{\emph{unequal} does not refer to \code{operator==}, but to
the notion of equality exemplified by iec559 for floating point. It's the answer
to the question "what should \code{unique} do (by default)?".}
 

\section{Fixups}
The algorithms section contains a few other algorithms:\footnote{Not to be
  confused with the types of their results; those end in \code{-ing}:
\code{strong\_ordering}, \code{weak\_ordering} etc.}

\begin{itemize}
  \item \code{weak\_order(const T\& a, const T\& b)}
  \item \code{partial\_order(const T\& a, const T\& b)}
  \item \code{strong\_equal(const T\& a, const T\& b)}
  \item \code{weak\_equal(const T\& a, const T\& b)}
  \item \code{partial\_equal(const T\& a, const T\& b)}
\end{itemize}

Intuitively, one would expect that if \StrongOrder is available, then so are
\code{strong\_equal}, \code{weak\_order} and \code{partial\_order} (with
\code{weak\_equal} and \code{partial\_equal} being consequences of those). The
current situation seems to provide for that by pure accident\footnote{the rules
are identical, except for the iec559 exception in \StrongOrder, while
floating-point types possess \code{operator<} and \code{operator==}, thus
enabling the presence of all those primitives.}, with no reference to this fact.

However, if \StrongOrder is the customization point for a default order
that \emph{may} be stronger than the order on operator \spaceship, then the
above expectation may longer hold for such types.

The fix-up for each of the sections describing the above primitives would be to
insert, after point x.1 (which describes the algorithm in terms of \spaceship)
the automatic fallback to a call to \StrongOrder, if it is resolvable 
through an unqualified call (thus enabling argument-dependent lookup).

\section{Alternative}
If the purpose of \StrongOrder is not enabling a default-ordering for
types, the iec559 exception should be removed from the wording, and a different
customization point (perhaps called \code{total\_order}) added for the express
purpose of providing an arbitrary total order on the entire domain of a type.

\section{Acknowledgments} 
I would like to thank Thomas Köppe for his valuable comments, review, and most
of all some extremely clear and laconic wording; Roger Orr for bringing this
to my attention; Sam Finch for \emph{thoroughly} breaking my example and great
substantive comments, and pointing out that the current definition actually
breaks types that define a partially-ordered set of comparison operators.

\printbibliography


\end{document}

